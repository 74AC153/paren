*add quote syntactic shorthand
*tail-call-optimize if
*tail call optimization -- done?
move existing 'builtins' into eval, i.e. create special node types, etc
remname 'builtin' to 'foreign'
rename *_noref to *
rename node_remember/forget to node_makeroot/droproot
continuations -- make eval totally non-recursive laying breadcrumbs
macros -- write a parser in scheme

remote eval -- pending

test
test
test



tracing garbage collector with refcounting hints
refcounting for immediate jumping processing queue to be freed,

split out memcell layer from node layer



allow def! to take a value as well

currently working on:
- automatic refcount bumping audit

no automatic refcount bumping UNLESS explicitly adding links via constructors

switch token.c to node-based allocator

Lexical scope
when creating a lambda function, must also have 'defining environment' so that bound variables at the time of instantiation can be accessed. i.e. lambda forms must have:
  - ptr to actual function expression to be evaluated
  - ptr to variable names that are to be bound when a call is made
  - ptr to environment at the time of the lambda definition

when function calls are made, both name->argument bindings for the subroutine environment as well as the parent environment (at time of subroutine definition) are passed.

Tail call elimination must then take into account defining environment, but can
still dispose "current" environment when (re)starting a function.

When a subroutine is invoked, then, the environment stack is actually a mixture of 'definition environments' and 'function call stack' environments: at each node in the function call stack, there is a pointer to the definition environment, as well as a pointer to the variable binding environments.

change node_next_noref to be default behavior

tail call elimination
-- requires rewrite of eval to be non-recursive
call/cc?


add unit tests for parse and eval:

parse tests:
()
a
(())
(a)
(a ())
(() a)
(a . ())
(() . a)

(a b)
(b a)
(a . b)
(b . a)

(a b . c)

(a (b))
((b) a)
(a . (b))
((b) . a)

((a) (b))
((b) (a))
((a) . (b))
((b) . (a))

eval tests:
()
a
1
(a . b)

(quote ())
(quote 1)
(quote a)
(quote (a . b))

(def! W)
(def! X)
(def! Y)
(def! Z)

(set! W (quote ()))
(set! X (quote a))
(set! Y (quote 1))
(set! W (quote (a . b)))

(atom W)
(atom X)
(atom Y)
(atom Z)

(car W)
(car X)
(car Y)
(car Z)

(cdr W)
(cdr X)
(cdr Y)
(cdr Z)


(if () (quote a) (quote b))
(if a (quote a) (quote b))
(if 1 (quote a) (quote b))
(if (quote ()) (quote a) (quote b))
(if (quote a) (quote a) (quote b))
(if (quote 1) (quote a) (quote b))
(if (quote (a . b)) (quote a) (quote b))

(lambda () a)
(lambda a a)
(lambda (a) a)
(lambda (a . b) (a b))



cons

eq
defbang
setbang

(quote ())
(eq () (quote ()))
(eq () (quote (())))
(lambda (x) (car x))

(lambda () 9)
(label foo (lambda () 9))

(label next (lambda (x) (car (cdr x))))

(label my_car (lambda (x) (car x)))
(my_car (quote (a b)))

test lexical scope:
(label myfun (lambda () (label x 5)
                        (label five (lambda () x))
                        (label x 6)
                        (five)
             )
)

(label myfun (lambda () (label x 5) (label five (lambda () x)) (label x 6) (five)))

((lambda (a . b) (cons a (cons a ()))) 1 2 3)

(def! last-item-rec)
(set! last-item-rec (lambda (first rest)
                        (if (eq rest ())
                            first
                            (last-item-rec (car rest) (cdr rest)))))

(set! last-item-rec (lambda (first rest) (if (eq rest ()) first (last-item-rec (car rest) (cdr rest)))))

(def! last-item)
(set! last-item (lambda (l) (last-item-rec (car l) (cdr l))))
(last-item '(a b c))

(def! reverse)
(set! reverse (lambda (fwd rev) (if (eq fwd ()) rev (reverse (cdr fwd) (cons (car fwd) rev)))))
(reverse (quote (1 2 3)) ())


add operators:

nil?
atom?
list?
value?
symbol?
lambda?
...

+
-
*
/
%

<<
>>
->>
|
&
^
~

<
>
<=
>=
!=

&&
||
!

add string tokenizer pass
add quote parse pass

variadic functions?:
(lambda (foo &rest bar)) ?
(lambda all-args all-args) and (lambda (first-arg second-arg . other-args) ?

macros


reduce number of retain/releases by using _noref more often

move builtins into evaluator?

create native builtin node types?

switch to slist to reduce code size

replace cond with not-nil?

add let builtin to push environment

distributed multithreaded, send on request when crossing address spaces
- "hypernodes" represent cross-space links
- need to work out serialization method

make it so parse doesn't consume entire string if there are multiple lists in input string
remove dead node type

